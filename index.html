<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Cobb Pro - Direcci√≥n Inteligente</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { font-family: sans-serif; background: #f0f0f0; margin: 0; padding: 20px; text-align: center; }
    .container { display: flex; flex-direction: column; align-items: center; gap: 20px; }
    .viewer { 
      width: 95%; max-width: 900px; background: #000; border: 2px solid #333;
      min-height: 400px; position: relative; overflow: hidden;
    }
    canvas { display: block; cursor: crosshair; touch-action: none; }
    .controls { background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); width: 95%; max-width: 900px; }
    #output { font-size: 1.8em; color: #d32f2f; font-weight: bold; margin: 10px 0; }
    button { padding: 10px 15px; margin: 5px; cursor: pointer; border-radius: 4px; border: 1px solid #ccc; background: #fff; font-weight: bold; }
    #instruction { color: #0066cc; font-weight: bold; margin-bottom: 10px; }
  </style>
</head>
<body>

  <h2>Medici√≥n de √Ångulo de Cobb</h2>
  <p id="instruction">Carga una imagen para comenzar</p>

  <div class="container">
    <div class="controls">
      <input type="file" id="imageInput" accept="image/*" style="margin-bottom: 10px;"><br>
      <button id="flipBtn">‚ÜîÔ∏è Reflejar (Espejo)</button>
      <button id="undoBtn">‚Ü©Ô∏è Deshacer (cmd+z)</button>
      <button id="resetBtn">üóëÔ∏è Reiniciar</button>
      <div style="margin: 10px 0; display: inline-block;">
        <label>Tama√±o marcas:</label>
        <input type="range" id="sizeSlider" min="4" max="25" value="10">
      </div>
      <div id="output">√Ångulo: --¬∞</div>
    </div>
    <div class="viewer" id="viewer"><canvas id="canvas"></canvas></div>
  </div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const imageInput = document.getElementById("imageInput");
    const output = document.getElementById("output");
    const flipBtn = document.getElementById("flipBtn");
    const undoBtn = document.getElementById("undoBtn");
    const resetBtn = document.getElementById("resetBtn");
    const sizeSlider = document.getElementById("sizeSlider");

    let img = new Image();
    let points = []; 
    let scale = 1;
    let isFlipped = true;
    let draggingPoint = null;

    imageInput.onchange = e => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        img = new Image();
        img.onload = () => {
          const containerWidth = document.getElementById("viewer").clientWidth;
          scale = containerWidth / img.width;
          canvas.width = containerWidth;
          canvas.height = img.height * scale;
          points = [];
          draw();
        };
        img.src = ev.target.result;
      };
      reader.readAsDataURL(file);
    };

    function getMousePos(e) {
      const rect = canvas.getBoundingClientRect();
      let x = (e.clientX - rect.left) / scale;
      let y = (e.clientY - rect.top) / scale;
      if (isFlipped) x = img.width - x;
      return { x, y };
    }

    canvas.onmousedown = e => {
      const pos = getMousePos(e);
      const hitRadius = 25 / scale;
      draggingPoint = points.find(p => Math.hypot(p.x - pos.x, p.y - pos.y) < hitRadius);
      if (!draggingPoint && points.length < 4) points.push({ x: pos.x, y: pos.y });
      draw();
    };

    window.onmousemove = e => {
      if (draggingPoint) {
        const pos = getMousePos(e);
        draggingPoint.x = pos.x;
        draggingPoint.y = pos.y;
        draw();
      }
    };

    window.onmouseup = () => { draggingPoint = null; };
    flipBtn.onclick = () => { isFlipped = !isFlipped; draw(); };
    resetBtn.onclick = () => { points = []; output.innerHTML = "√Ångulo: --¬∞"; draw(); };
    undoBtn.onclick = undo;
    window.addEventListener('keydown', e => { if ((e.metaKey || e.ctrlKey) && e.key === 'z') { e.preventDefault(); undo(); } });

    function undo() { if (points.length > 0) { points.pop(); draw(); } }

    function drawLine(p1, p2, color) {
      ctx.beginPath();
      ctx.strokeStyle = color;
      ctx.lineWidth = 3 / scale;
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
    }

    function draw() {
      if (!img.src) return;
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.translate(isFlipped ? canvas.width : 0, 0);
      ctx.scale(isFlipped ? -scale : scale, scale);
      ctx.drawImage(img, 0, 0);

      const s = parseInt(sizeSlider.value) / scale;

      if (points.length >= 2) drawLine(points[0], points[1], "#007bff");
      if (points.length >= 4) {
        drawLine(points[2], points[3], "#28a745");
        
        // 1. C√°lculo de Cobb
        const v1 = { x: points[1].x - points[0].x, y: points[1].y - points[0].y };
        const v2 = { x: points[3].x - points[2].x, y: points[3].y - points[2].y };
        let cobb = Math.acos(Math.min(1, Math.max(-1, (v1.x*v2.x + v1.y*v2.y) / (Math.hypot(v1.x, v1.y) * Math.hypot(v2.x, v2.y))))) * 180 / Math.PI;
        if (cobb > 90) cobb = 180 - cobb;
        output.innerHTML = `√Ångulo de Cobb: ${cobb.toFixed(1)}¬∞`;

        // 2. Perpendiculares inteligentes
        const mid1 = { x: (points[0].x + points[1].x)/2, y: (points[0].y + points[1].y)/2 };
        const mid2 = { x: (points[2].x + points[3].x)/2, y: (points[2].y + points[3].y)/2 };
        
        const drawSmartPerp = (pInicio, pFin, m, col) => {
            const dx = pFin.x - pInicio.x;
            const dy = pFin.y - pInicio.y;
            const anguloBase = Math.atan2(dy, dx);
            
            // Si el punto medio est√° arriba de la mitad de la imagen, la perpendicular debe ir hacia abajo
            // Usamos el signo del producto cruzado o rotaci√≥n fija para asegurar direcci√≥n central
            let direccion = (m.y < img.height / 2) ? 1 : -1;
            
            // Ajuste especial: si dx es negativo (se marc√≥ de derecha a izquierda), invertimos la direcci√≥n
            if (dx < 0) direccion *= -1;

            const px = Math.cos(anguloBase + Math.PI/2 * direccion) * (400/scale);
            const py = Math.sin(anguloBase + Math.PI/2 * direccion) * (400/scale);

            ctx.beginPath();
            ctx.strokeStyle = col;
            ctx.setLineDash([5/scale, 5/scale]);
            ctx.moveTo(m.x, m.y);
            ctx.lineTo(m.x + px, m.y + py);
            ctx.stroke();
            ctx.setLineDash([]);
        };

        drawSmartPerp(points[0], points[1], mid1, "#007bff");
        drawSmartPerp(points[2], points[3], mid2, "#28a745");

        // 3. Dibujar Arco y Texto en el centro
        ctx.save();
        const centerX = (mid1.x + mid2.x) / 2;
        const centerY = (mid1.y + mid2.y) / 2;
        
        // Arco visual (amarillo)
        ctx.beginPath();
        ctx.strokeStyle = "yellow";
        ctx.lineWidth = 2 / scale;
        ctx.arc(centerX, centerY, 35/scale, 0, Math.PI*2); // Representaci√≥n simb√≥lica del √°ngulo
        ctx.stroke();

        ctx.setTransform(1, 0, 0, 1, 0, 0);
        const screenX = isFlipped ? canvas.width - (centerX * scale) : centerX * scale;
        const screenY = centerY * scale;
        ctx.fillStyle = "yellow";
        ctx.shadowColor = "black";
        ctx.shadowBlur = 5;
        ctx.font = "bold 24px Arial";
        ctx.textAlign = "center";
        ctx.fillText(`${cobb.toFixed(1)}¬∞`, screenX, screenY - 10);
        ctx.restore();
      }

      points.forEach((p, i) => {
        ctx.beginPath();
        ctx.fillStyle = i < 2 ? "#007bff" : "#28a745";
        ctx.arc(p.x, p.y, s, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "white";
        ctx.lineWidth = 1/scale;
        ctx.stroke();
      });
    }

    sizeSlider.oninput = draw;
  </script>
</body>
</html>